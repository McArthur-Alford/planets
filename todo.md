# TODO:
## Geometry
Abstract everything into a GeometryData object.

GeometryData
- Vertices
- Faces
- Cells mapping

Functions:
*dual* function which computes the dual.
*subdivide* function which subdivides triangles.
*slerp* function which slerps.
*irregularize* function which snips a random vertex. This can be done in 2 ways:
  1. Find two triangles that share an edge. remove that edge, connect the points opposite the edge by a new edge. This will produce heptagons.
  2. Pick a random edge. Replace its 2 vertices with 1 at the center of the edge, and have all edges going to either *original* vertex now point to the new central one. This will produce octagons.
  3. If one of the above operations would produce a vertex with too many or too few (a customisable parameter) amount of edges, cancel it and pick a new one.
*relax* function, which uses Lloyd's algorithm to relaxation (more evenly distributing points) by moving a vertex to the average position of its cell (which it might not initially be in). https://en.wikipedia.org/wiki/Lloyd%27s_algorithm
  - The paper uses an alternative relaxation approach, having an ideal equilateral *triangle* computed and comparing the vertex to centroid distances with the ideal. Push vertices to slightly get closer to the ideal.

Each vertex maps to a cell. To find its faces:
- Find the faces of all triangles such that the vertex is in that triangle
- Group them as faces for that cell
- (Perhaps have a btreemap that we fill as we construct faces)
  - Add the index of a new face to each of its 3 vertices in the map when its made.
  - Remove the index of the old pre-subdivided face from *its* 3 vertices.

## Chunking
Chunk
- A list of cell indexes that belong to the chunk.
- A local geometrydata which is initially empty.
  - Generated by yoinking indices from the reference geometry data.
  - Mapping them to local indices and bam done.
- A mapping of global cell indices to local cell indices for coloration.
  - Generated alongside the geometrydat

Functions:
*Generate* (does the obvious, takes a reference geometry data to steal from)

Chunker
- A desired chunk size or desired amount of chunks (enum?) + a minimum chunk size
- Takes a geometrydata, samples a random point, gets N adjacent neighbours (flood fill), groups.
  - Repeat this for all cells.
  - Probably can be parallelised in future.
- Run it in parallel to bevy and dont let it hog the CPU. Have it shoot the finished chunks out in a stream to a system that then spawns associated meshes + chunk entities as needed.


## LODS
ChunkChunker
- Chunks chunks into smaller chunks (a desired amount of chunks to split into + a minimum chunk size)
  - When doing this, aims for roughly hexagonal shapes using floodfill.
  - Keep chunking until everything is at the minimum chunk size.

ChunkHeirarchy
- Stores the current level of detail.
- Stores a vec<vec<chunk>> where increasing indexes are decreasing levels of detail. therefore, at index 0 its a true resolution of real hexes.
- We can use this to decide which chunk to render.
  - Upon LOD change, nuke all children and spawn meshes of the desired LOD.

NOTE:
- This doesn't actually reduce the mesh complexity, but it means that larger, further away meshes can be combined so that bevy doesnt have to have a million small meshes, but at the same time the up-close meshes *can* be small.
- It opens the possibility of culling the interior vertices later on and just having the outline + one central vertex to do actual LOD vertex reduction later on.

## Meshing
A function to turn a GeometryData into a mesh. (Great now that chunks store GeometryData!)
Fairly straightforward really.

## Coloring
The coloring system works as usual. A slight tweak is that it bundles colours by chunk and only colors chunks that have >X% of cells ready to be changed. This should be such that the smallest chunk size possible changes when 1 cell is updated.

- **this can also be done for normalas**, and later on we can have height + slope dictate a slight offset to the normal (so that mountains reflect properly as though 3d, for example).

## Click detection:
> TODO
- Calculate the line-sphere intersection to find the click location.
- Somehow determine which cell we are inside of...

 
